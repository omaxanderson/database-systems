/* Copyright (C) Mike Zmuda - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Mike Zmuda <zmudam@miamioh.edu>, 2010-2015
 */
//TEST
package Al;

import breakthrough.BreakthroughState;
import game.GamePlayer;
import game.GameMove;

public abstract class BaseBreakthroughPlayer extends GamePlayer {
	public static int ROWS = BreakthroughState.N;
	public static int COLS = BreakthroughState.N;
	public static final int MAX_SCORE = 20*BreakthroughState.N*BreakthroughState.N + 1;

	public static double WEIGHT_ONE = 0;
	public static double WEIGHT_TWO = 0;
	public static double WEIGHT_THREE = 0;
	public static double WEIGHT_FOUR = 0;
	public static double WEIGHT_FIVE = 0;
	public static double WEIGHT_SIX = 0;
	public static double WEIGHT_SEVEN = 0;
	public static double WEIGHT_EIGHT = 1;

	public BaseBreakthroughPlayer(String nname)
	{ super(nname, "Breakthrough");	}

	// Count number of who's pieces left on the board
	private static int eval(BreakthroughState brd, char who)
	{
		int cnt = 0;
		for (int i = 0; i < BreakthroughState.N; i++) {
			for (int c = 0; c < BreakthroughState.N; c++) {
				if (brd.board[i][c] == who) {
					cnt++;
				}
			}
		}

		return cnt;
	}

	// Weight the number of pieces on the board to how close they are to the opponents side
	private static int eval2(BreakthroughState brd, char who) {
		int cnt = 0;
		for (int i = 0; i < BreakthroughState.N; i++) {
			for (int c = 0; c < BreakthroughState.N; c++) {
				if (brd.board[i][c] == who) {
					cnt += (who == BreakthroughState.homeSym ? i + 1 : BreakthroughState.N - i);
				}
			}
		}
		return cnt;
	}

	// Count number of friendly pieces adjacent (horizontally) to one another
	private static int eval3(BreakthroughState brd, char who) {
		int cnt = 0;
		for (int i = 0; i < BreakthroughState.N; i++) {
			for (int c = 0; c < BreakthroughState.N - 1; c++) {
				if (brd.board[i][c] == who && brd.board[i][c + 1] == who) {
					cnt++;
				}
			}
		}

		return cnt;
	}

	// Count number of friendly pieces adjacent (vertically) to one another
	private static int eval4(BreakthroughState brd, char who) {
		int cnt = 0;
		for (int i = 0; i < BreakthroughState.N - 1; i++) {
			for (int c = 0; c < BreakthroughState.N; c++) {
				if (brd.board[i][c] == who && brd.board[i + 1][c] == who) {
					cnt++;
				}
			}
		}

		return cnt;
	}
	
	// count the number of spaces being attacked
	private static int eval5(BreakthroughState brd, char who) {
		int cnt = 0;
		int dir = (who == BreakthroughState.homeSym ? 1 : -1);
		boolean isHome = (who == BreakthroughState.homeSym);
		for (int i = 0; i < BreakthroughState.N - 1; i++) {
			for (int j = 0; j < BreakthroughState.N - 1; j++) {
				if (brd.board[i][j] == who) {
					if (j - 1 >= 0 && j + 1 <= BreakthroughState.N - 1 && i + dir < BreakthroughState.N && i + dir >= 0) {
						if (brd.board[i + dir][j - 1] != who) {
							cnt++;
						}
						if (brd.board[i + dir][j + 1] != who) {
							cnt++;
						}
					}
				}
			}
			
		}
		return cnt;
	}
	
	// count the diagonals 
	public static int eval6(BreakthroughState brd, char who) {
		// if home, check i = 5-7 and j = 0-5, then j = 2 - 7
		// 	  away, check i = 0-2 and j = 0-5, j = 2-7
		int count = 0;
		boolean isHome = (who == BreakthroughState.homeSym);
		// int dir = (who == BreakthroughState.homeSym ? 1 : -1);
		for (int i = isHome ? BreakthroughState.N / 2 : 0; i < (isHome ? (BreakthroughState.N / 2) + 2: 2); i++) {
			for (int j = 0; j < BreakthroughState.N - 2; j++) {
				if (brd.board[i][j] == BreakthroughState.emptySym && 
						brd.board[i + 1][j + 1] == BreakthroughState.emptySym &&
						brd.board[i + 2][j + 2] == BreakthroughState.emptySym) {
					count++;
				}
			}
			for (int j = 2; j < BreakthroughState.N; j++) {
				if (brd.board[i][j] == BreakthroughState.emptySym && 
						brd.board[i + 1][j - 1] == BreakthroughState.emptySym &&
						brd.board[i + 2][j - 2] == BreakthroughState.emptySym) {
					count++;
				}
			}
		}
		return count;
	}
	
	// find solo pieces
	public static int eval7(BreakthroughState brd, char who) {
		int count = 0;
		char opponent = (who == BreakthroughState.homeSym ? 
								BreakthroughState.awaySym : BreakthroughState.homeSym);
		for (int i = 1; i < BreakthroughState.N - 1; i++) {
			for (int j = 1; j < BreakthroughState.N - 1; j++) {
				if (brd.board[i][j] == opponent) {
					// check the full circle
					if (brd.board[i - 1][j] == BreakthroughState.emptySym &&
							brd.board[i - 1][j + 1] == BreakthroughState.emptySym &&
							brd.board[i][j + 1] == BreakthroughState.emptySym &&
							brd.board[i + 1][j + 1] == BreakthroughState.emptySym &&
							brd.board[i + 1][j] == BreakthroughState.emptySym &&
							brd.board[i + 1][j - 1] == BreakthroughState.emptySym &&
							brd.board[i][j - 1] == BreakthroughState.emptySym &&
							brd.board[i - 1][j - 1] == BreakthroughState.emptySym) {
						count++;
					}
				}
			}
		}
		return count;
	}

	// look for open columns to exploit
	public static int eval8(BreakthroughState brd, char who) {
		int count = 0;
		char opponent = (who == BreakthroughState.homeSym ? BreakthroughState.awaySym : BreakthroughState.homeSym);
		for (int i = 0; i < BreakthroughState.N; i++) {
			boolean isEmpty = true;
			for (int j = 0; j < BreakthroughState.N; j++) {
				if (brd.board[j][i] == opponent) {
					isEmpty = false;
				}
			}
			if (isEmpty) {
				count += 2;
			}
		}
		return count;
	}
	
	// # of supported pieces
	public static int eval9(BreakthroughState brd, char who) {
		int count = 0;
		for (int i = 0; i < BreakthroughState.N; i++) {
			for (int j = 0; j < BreakthroughState.N; j++) {
				continue;
			}
		}
		return 1;
	}
	
	// weighted 
	
	public static int evalBoard(BreakthroughState brd)
	{
		//int score = eval(brd, BreakthroughState.homeSym) - eval(brd, BreakthroughState.awaySym);
		double sc = WEIGHT_ONE * (eval(brd, BreakthroughState.homeSym) - eval(brd, BreakthroughState.awaySym));
		//sc += WEIGHT_TWO * (eval2(brd, BreakthroughState.homeSym) - eval2(brd, BreakthroughState.awaySym));
		//sc += WEIGHT_THREE * (eval3(brd, BreakthroughState.homeSym) - eval3(brd, BreakthroughState.awaySym));
		//sc += WEIGHT_FOUR * (eval4(brd, BreakthroughState.homeSym) - eval4(brd, BreakthroughState.awaySym));
		//sc += WEIGHT_FIVE * (eval5(brd, BreakthroughState.homeSym) - eval5(brd, BreakthroughState.awaySym));
		//sc += WEIGHT_SIX * (eval6(brd, BreakthroughState.homeSym) - eval6(brd, BreakthroughState.awaySym));
		//sc += WEIGHT_SEVEN * (eval7(brd, BreakthroughState.homeSym) - eval7(brd, BreakthroughState.awaySym));
		sc = WEIGHT_EIGHT * (eval8(brd, BreakthroughState.homeSym) - eval8(brd, BreakthroughState.awaySym));

		int score = (int)Math.round(sc);
		if (Math.abs(score) > MAX_SCORE) {
			System.err.println("Problem with eval");
			System.exit(0);
		}
		return score;
	}
	
}
